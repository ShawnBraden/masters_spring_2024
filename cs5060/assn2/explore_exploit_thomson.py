
import scipy
from scipy import stats
import numpy as np
import matplotlib.pyplot as plt
import random

#simulation pramaters
num_machines = 21
convergance = 1.5
sim_iter = 10000
success_critia = 1.5
drift = True
reset = True

def get_probabilities(drift=0, time=0):
    if time < 300:
        probs = [
            np.random.normal(0-(drift * time), 5),
            np.random.normal(-0.5-(drift * time),12),
            np.random.normal(2-(drift * time),3.9),
            np.random.normal(-0.5-(drift * time),7),
            np.random.normal(-1.2-(drift * time),8),
            np.random.normal(-3-(drift * time),7),
            np.random.normal(-10-(drift * time),20),
            np.random.normal(-0.5-(drift * time),1),
            np.random.normal(-1-(drift * time),2),
            np.random.normal(1-(drift * time),6),
            np.random.normal(0.7-(drift * time),4),
            np.random.normal(-6-(drift * time),11),
            np.random.normal(-7-(drift * time),1),
            np.random.normal(-0.5-(drift * time),2),
            np.random.normal(-6.5-(drift * time),1),
            np.random.normal(-3-(drift * time),6),
            np.random.normal(0-(drift * time),8),
            np.random.normal(2-(drift * time),3.9),
            np.random.normal(-9-(drift * time),12),
            np.random.normal(-1-(drift * time),6),
            np.random.normal(-4.5-(drift * time),8)              
        ]
    else: 
        mean_7 = -0.5-(drift * time + 1)
        x = np.random.normal(mean_7,1) 

        probs = [
            np.random.normal(0-(drift * time) + 7, 5),
            np.random.normal(-0.5-(drift * time),12),
            np.random.normal(2-(drift * time) + 3,3.9),
            np.random.normal(-0.5-(drift * time),7),
            np.random.normal(-1.2-(drift * time),8),
            np.random.normal(-3-(drift * time),7),
            np.random.normal(-10-(drift * time),20),
            x if x < (mean_7) + 3 else 50,
            np.random.normal(-1-(drift * time),2),
            np.random.normal(1-(drift * time),6),
            np.random.normal(0.7-(drift * time),4),
            np.random.normal(-6-(drift * time),11),
            np.random.normal(-7-(drift * time),1),
            np.random.normal(-0.5-(drift * time),2),
            np.random.normal(-6.5-(drift * time),1),
            np.random.normal(-3-(drift * time),6),
            np.random.normal(0-(drift * time),8),
            np.random.normal(2-(drift * time),3.9),
            np.random.normal(-9-(drift * time) + 3,12),
            np.random.normal(-1-(drift * time),6),
            np.random.normal(-4.5-(drift * time),8)              
        ]
    return probs

class explore_exploit():
    def __init__(self, sim_iter:int = 10000, num_machines:int = 21, convergance:int = 2, window_size:int = 10000, success_critia:float = 1.5, drift:bool = False, reset:bool = False) -> None:
        self.__sim_iter = sim_iter
        self.__reward = 0
        self.__num_machines = num_machines
        self.__machines_info = []
        for i in range(self.__num_machines):
            self.__machines_info.append([1, 1]) #NOTE: The first index is alpha and the second index is beta
        self.__convergance = convergance
        self.__convergance_time_step = -1
        self.__history_of_avg = [0] * self.__sim_iter
        self.__window_size = window_size
        self.__last_window = [0] * self.__window_size
        self.__success_critia = success_critia
        self.__drift = drift
        self.__reset = reset
    def run_sim(self):
        convert_to_window_size = self.__sim_iter // self.__window_size
        for time in range(1, self.__sim_iter + 1):
            #save the old avg
            self.__history_of_avg[time - 1] = self.__reward
            sample = self.get_action(time)
            # to get the new avg of the last windo of samples (or how many we have if we have less than one window)
            if time < self.__window_size:
                self.__last_window[time] = sample
                tmp = sum(self.__last_window[:time])
                self.__reward = tmp / time
            else :
                self.__last_window[time % convert_to_window_size] = sample
                tmp = sum(self.__last_window)
                self.__reward = tmp / self.__window_size
            if time == 3000 and self.__reset:
                self.__machines_info = []
                for i in range(self.__num_machines):
                    self.__machines_info.append([1, 1]) #NOTE: The first index is alpha and the second index is beta
                print("Reset Thomson Samapling")
        return (self.__machines_info, self.__reward, self.__convergance_time_step, self.__history_of_avg) 
    def get_action(self, time):
        if self.__drift:
            draw = get_probabilities(time=time)
        else :
            draw = get_probabilities()
        #sample the thomson distros
        samples = [np.random.beta(machine[0], machine[1]) for machine in self.__machines_info]
        #find the max val from the sample spaces, and use that as the machine to act on.
        machine_to_explore = max(range(self.__num_machines), key=lambda x: samples[x])
        #decide if it is success or failure. 
        is_success = True if draw[machine_to_explore] > self.__success_critia else False
        #update the machines_info
        if is_success:
            self.__machines_info[machine_to_explore][0] += 1
        else :
            self.__machines_info[machine_to_explore][1] += 1
        return draw[machine_to_explore]
def main():
    explore = explore_exploit(num_machines=num_machines, convergance=convergance, sim_iter=sim_iter, success_critia=success_critia, drift=drift, reset=reset)
    run_info = explore.run_sim()

    machines_info = run_info[0]
    data_history_avg = run_info[3]
    data_convegance = run_info[2]

    plt.plot(data_history_avg, label = "AVG reward Convergance Line")
    plt.xlabel('Time step')
    plt.ylabel('AVG reward')
    plt.legend()

    fig, axs = plt.subplots(5, (num_machines // 5) + 1, figsize=(18,8))
    axs = axs.flatten()

    x = np.linspace(0,1,100)
    for i in range(num_machines):
        machine = machines_info[i]
        # Plot on the current subplot
        axs[i].plot(stats.beta(machine[0], machine[1]).pdf(x))
        axs[i].set_title(f'Beta Distrobution of Machine {i}')
    
    plt.subplots_adjust(left=0.1, right=0.9, top=0.9, bottom=0.1, wspace=0.4, hspace=0.4)
    
    

    plt.show()

    


if __name__ == "__main__":
    main()
        